<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池线程池的概念及优点 线程池相关API 线程池优点 创建线程池代码实现 面试问题：创建多线程有几种方式？ 4种 extends Thread类； implements Runnable； implements Callable； 线程池。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Callable接口]]></title>
    <url>%2F2020%2F08%2F16%2FCallable%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Callable接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sleep方法与wait方法的异同]]></title>
    <url>%2F2020%2F08%2F16%2Fsleep%E6%96%B9%E6%B3%95%E4%B8%8Ewait%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[sleep方法与wait方法的异同相同点 一旦执行方法，都可以使得当前线程进入阻塞状态。 不同点 两个方法声明的位置不同：Thread类中声明sleep（），Object类中声明wait（）； 调用的要求不同：sleep（）可以在任何需要的场景下调用，wait（）必须在同步代码块或者同步方法中调用； 关于是否释放同步监视器：如果两个方法都在同步代码块或者同步方法中，sleep（）方法不释放锁， wait（）方法释放锁。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程通信的方法]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[线程通信的方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock]]></title>
    <url>%2F2020%2F08%2F16%2FLock%2F</url>
    <content type="text"><![CDATA[Lock]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程安全的懒汉式]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[线程安全的懒汉式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步代码块与同步方法]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[同步代码块与同步方法 未解决线程安全问题，有两种方法，分别是同步代码块与同步方法。 同步代码块Runnable实现方法 同步代码块Runnable实现方法代码实现 同步代码块extends代码实现方法 同步方法总结 同步方法仍然涉及到同步监视器，只是不需要我们显式声明； 非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的安全问题]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[线程的安全问题]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的生命周期]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[线程的生命周期]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序、进程、线程概念]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[程序、进程、线程概念]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程创建方式比较]]></title>
    <url>%2F2020%2F08%2F16%2F%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[线程创建方式比较]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Runnable接口]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[实现Runnable接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程优先级设置]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[多线程优先级设置]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程常用方法]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[多线程常用方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主线程]]></title>
    <url>%2F2020%2F08%2F16%2F%E4%B8%BB%E7%BA%BF%E7%A8%8Bmd%2F</url>
    <content type="text"><![CDATA[主线程]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句通用语法]]></title>
    <url>%2F2020%2F08%2F16%2FSQL%E8%AF%AD%E5%8F%A5%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL语句通用语法]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要使用PreparedStatement]]></title>
    <url>%2F2020%2F08%2F16%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8PreparedStatement%2F</url>
    <content type="text"><![CDATA[为什么要使用PreparedStatement PreparedStatement接口继承Statement， PreparedStatement 实例包含已编译的 SQL 语句，所以其执行速度要快于 Statement 对象。 作 为 Statement 的 子 类 ， PreparedStatement 继承了 Statement 的 所 有 功 能 。 三 种 方法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数 在 JDBC应用中,在任何时候都不要使用Statement，原因如下：一、代码的可读性和可维护性.Statement需要不断地拼接，而PreparedStatement不会。二、PreparedStatement尽最大可能提高性能.DB有缓存机制，相同的预编译语句再次被调用不会再次需要编译。三、最重要的一点是极大地提高了安全性.Statement 容易被 SQL 注入，而 PreparedStatementc 传入的内容不会和sql语句发生任何匹配关系。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生jdbc操作数据库流程]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%8E%9F%E7%94%9Fjdbc%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[原生jdbc操作数据库流程 第一步：Class.forName()加载数据库连接驱动； 第二步：DriverManager.getConnection()获取数据连接对象; 第三步：根据SQL获取sql会话对象，有2种方式 Statement、PreparedStatement ; 第四步：执行SQL处理结果集，执行SQL前如果有参数值就设置参数值setXXX(); 第五步：关闭结果集、关闭会话、关闭连接。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC概念]]></title>
    <url>%2F2020%2F08%2F16%2FJDBC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[JDBC概念]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB范式]]></title>
    <url>%2F2020%2F08%2F16%2FDB%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[DB范式]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据表的CRUD]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[MySQL数据表的CRUD 创建表 查询修改与删除表 增删改查表中数据]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[MySQL数据类型]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序（Java）]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89%2F</url>
    <content type="text"><![CDATA[堆排序（Java）上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.text.SimpleDateFormat;import java.util.Date;public class HeapSort &#123; public static void main(String[] args) &#123; //升序排列 //int[] arr = &#123;4,6,8,5,9&#125;; //创建80000个随机数 int[] arr = new int[8000000]; for (int i = 0; i &lt;8000000; i++) &#123; arr[i] = (int) (Math.random()*8000000);//生成一个[0,8000000）的数 &#125; //System.out.println(&quot;排序前：&quot;); //System.out.println(Arrays.toString(arr)); Date date1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;); String date1Str = simpleDateFormat.format(date1); System.out.println(&quot;排序前的时间是：&quot;+date1Str); long startMili=System.currentTimeMillis();// 当前时间对应的毫秒数 heapSort(arr); long endMili=System.currentTimeMillis(); //System.out.println(&quot;排序后：&quot;); //System.out.println(Arrays.toString(arr)); Date date2 = new Date(); String date2Str = simpleDateFormat.format(date2); System.out.println(&quot;排序后的时间是：&quot;+date2Str); double h = (endMili-startMili)/1000.0; System.out.println(&quot;总耗时为：&quot;+(endMili-startMili)+&quot;毫秒&quot;+&quot;=&quot;+ h + &quot;秒&quot;); &#125; public static void heapSort(int[] arr)&#123; int temp = 0; System.out.println(&quot;堆排序！&quot;); 分步完成 adjustHeap(arr, 1, arr.length); System.out.println(&quot;NO.1:&quot;+ Arrays.toString(arr)); adjustHeap(arr, 0 , arr.length); System.out.println(&quot;NO.2:&quot; + Arrays.toString(arr)); //一次完成 for (int i = arr.length / 2 - 1; i &gt;= 0 ; i--) &#123; adjustHeap(arr, i, arr.length); &#125; for (int j = arr.length - 1; j &gt; 0 ; j--) &#123; //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); &#125; //System.out.println(&quot;数组=&quot; + Arrays.toString(arr)); &#125; /** * 功能：完成将以i对应的非叶子节点的树调整为大顶堆 * 举例：&#123;4,6,8,5,9&#125; =&gt; i=1 =&gt;adjustHeap =&gt; &#123;4,9,8,5,6&#125; * @param arr 待调整数组 * @param i 非叶子节点在数组中的索引 * @param length 对多少个元素继续调整，length在减少 */ public static void adjustHeap(int[] arr,int i,int length)&#123; int temp = arr[i]; //取出当前元素，保存在临时变量 //开始调整 for (int k = i*2+1; k &lt;length ; k=k*2+1) &#123; if(k+1 &lt; length &amp;&amp; arr[k] &lt;a rr[k+1] )&#123; //左子节点小于右子节点 k++; //k指向右子节点 &#125; if(arr[k] &gt; temp)&#123; //如果子节点大于结点 arr[i] = arr[k]; //把较大的值赋值给当前结点 i = k; &#125; else&#123; break; &#125; &#125; //当for循环结束，我们已经将以i为父结点的树的最大值放在最顶 arr[i] = temp;//将temp放到最后调整的位置 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习 - 排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL图解功能分类]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E5%9B%BE%E8%A7%A3%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[MySQL图解功能分类]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL修改删除与使用语句]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[MySQL修改删除与使用语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL创建与查询语句]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[MySQL创建与查询语句]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语句分类]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[MySQL语句分类]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL通用语法]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MySQL通用语法]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装配置]]></title>
    <url>%2F2020%2F08%2F16%2FMySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MySQL安装配置]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于Java的GC哪些内存需要回收]]></title>
    <url>%2F2020%2F08%2F16%2F%E5%AF%B9%E4%BA%8EJava%E7%9A%84GC%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[对于Java的GC哪些内存需要回收 内存运行时 JVM 会有一个运行时数据区来管理内存。它主要包括 5 大部分：程序计数器(Program Counter Register)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap). 而其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的内存空间，随线程而生，随线程而亡。例如栈中每一个栈帧中分配多少内存基本上在类结构确定是哪个时就已知了，因此这 3 个区域的内存分配和回收都是确定的，无需考虑内存回收的问题。 但方法区和堆就不同了，一个接口的多个实现类需要的内存可能不一样，我们只有在程序运行期间才会知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC主要关注的是这部分内存。 总而言之，GC 主要进行回收的内存是JVM中的方法区和堆。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC什么时候回收垃圾]]></title>
    <url>%2F2020%2F08%2F16%2FGC%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%2F</url>
    <content type="text"><![CDATA[GC什么时候回收垃圾 关于方法区中需要回收的是一些废弃的常量和无用的类。 废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。 无用的类的回收。 什么是无用的类呢？ 该类所有的实例都已经被回收。也就是Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 结论 对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了4中引用，每种引用的回收机制也是不同的。 对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Properties集合]]></title>
    <url>%2F2020%2F08%2F15%2FProperties%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Properties集合]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection集合笔记]]></title>
    <url>%2F2020%2F08%2F15%2FCollection%E9%9B%86%E5%90%88%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Collection集合笔记]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库中的四种隔离]]></title>
    <url>%2F2020%2F08%2F15%2FMySQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[MySQL数据库中的四种隔离如下图： 读未提交（READ UNCOMMITTED）：未提交读隔离级别也叫读脏，就是事务可以读取其它事务未提交的数据。 读已提交（READ COMMITTED）：在其它数据库系统比如SQL Server默认的隔离级别就是提交读，已提交读隔离级别就是在事务未提交之前所做的修改其它事务是不可见的。 可重复读（REPEATABLE READ）：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。 可串行化（SERIALIZABLE）：可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库四大特征]]></title>
    <url>%2F2020%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[数据库四大特征数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆， 必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyISAM和InnoDB存储引擎]]></title>
    <url>%2F2020%2F08%2F15%2FMyISAM%E5%92%8CInnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[MyISAM和InnoDB存储引擎MyISAM存储引擎 MyISAM 是 MySQL 官方提供默认的存储引擎，其特点是不支持事务、表锁和全文索引，对于一些 OLAP（联机分析处理）系统，操作速度快。 每个MyISAM在磁盘上存储成三个文件。文件名都和表名相同，扩展名分别是.frm（存储表定义）、.MYD (MYData，存储数据)、.MYI (MYIndex，存储索引)。这里特别要注意的是MyISAM不缓存数据文件，只缓存索引文件。 InnoDB存储引擎 InnoDB 存储引擎支持事务，主要面向 OLTP（联机事务处理过程）方面的应用，其特点是行锁设置、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读不产生锁。InnoDB将数据放在一个逻辑表空间中（类似Oracle）。 InnoDB通过多版本并发控制来获得高并发性，实现了ANSI标准的4种隔离级别，默认为epeatable，使用一种被称为next-key locking的策略避免幻读。 对于表中数据的存储，InnoDB采用类似Oracle索引组织表Clustered的方式进行存储。InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比Myisam的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入问题]]></title>
    <url>%2F2020%2F08%2F14%2FSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[SQL注入问题 通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。当执行的sql为：select * from user where username = “admin” or “a”=“a”sql语句恒成立，参数admin毫无意义。 防止SQL注入方式： 预编译语句：如，select * from user where username = ？，sql语句语义不会发生改变，sql语句中变量用？表示，即使传递参数时为“admin or ‘a’= ‘a’”，也会把这整体当做一个字符创去查询。 Mybatis 框架中的mapper 方式中的 # 也能很大程度的防止sql注入（$无法防止sql注入）。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人logo]]></title>
    <url>%2F2019%2F07%2F21%2Flogo%2F</url>
    <content type="text"><![CDATA[个人logologo简介 我设计的个人logo为一个圆形，其中1/3的上半部分为黑色，2/3的下半部分为黄色，整个头像为一个抽象的人头像的一个概念，象征着一个有着黑头发黄皮肤的中国人的形象，简而言之，就是我自己。 logo设计灵感 我的个人网站logo灵感来自一直德甲的足球队——多特蒙德，外号是大黄蜂。再我上高中的时候，那时多特阵容豪华实力强劲，有着罗伊斯，莱万多夫斯基等众多球星，并且在2013年欧冠决赛与同为德甲的球队拜仁慕尼黑相遇。 当时还是一名高二学生的我被“大黄蜂”那黄黑的配色惊艳到了，再加之对内有两位高颜值且踢球技术超棒的帅锋，罗伊斯和莱万多夫斯基，于是我立马成了多特球迷。 可以说我也是通过一支球队培养了对黄色和黑色这样一种颜色组合的喜爱，对于我设计自己的logo有着许多影响。 logo设计风格 我本人是一个实用主义者，不喜欢太复杂的东西，这也给我设计自己的logo指明了方向：用最少的笔画表达我的个性，就是这样。]]></content>
      <categories>
        <category>简介</category>
      </categories>
      <tags>
        <tag>logo</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog——Markdown语法（基础篇）]]></title>
    <url>%2F2019%2F07%2F17%2FMarkdown%2F</url>
    <content type="text"><![CDATA[MK语法总结（Markdown语法笔记） 所有符号均为英文输入法状态下有效 基本操作 如上引用：大于号+空格 有序无序列表 减号+空格就是一个无序列表 有序列表，数字+英文句号+空格 百度超链接跳转,方括号+圆括号。方括号是跳转链接，圆括号是跳转的网址百度 插入图片：感叹号+中括号+小括号。中括号中是图片的描述实际不显示，小括号中是图片地址。 文字加粗：在要加粗文字外加两个星号，shift+8。 斜体：文字外面加一个星号。 引用本地图片的程序源码 引用图片的源代码 如上图，插入图片的MD语法。 引用本地图片： 本地图片保存在theme/next/source/images，这个路径下，所以如上图，图片路径以/images/开头，然后加上（图片名.后缀名）。 运用HTML语言的操作 设置字体、颜色和字号需运用HTML语言你好 居中： center标签 居左或居右： 你好 你好 图片居左居右同上。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 看这里看这里,Hello Hexo!Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
